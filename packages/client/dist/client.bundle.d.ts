// Generated by dts-bundle-generator v8.0.1

import { Component, IComponent, IWorld } from 'bitecs';
import { AnimationAction, AnimationClip, AnimationMixer, Clock, Group, Object3D, PerspectiveCamera, Raycaster, Scene, Texture, WebGLRenderer } from 'three';
import { GLTF } from 'three/examples/jsm/loaders/GLTFLoader';

export declare const NULL_EID = 0;
export declare const INITIAL_VERSION = 0;
export declare const SystemOrder: Readonly<{
	Time: 0;
	EventHandling: 100;
	Setup: 200;
	BeforeMatricesUpdate: 300;
	MatricesUpdate: 400;
	BeforeRender: 500;
	Render: 600;
	AfterRender: 700;
	PostProcess: 800;
	TearDown: 900;
}>;
export type Prefab = (world: IWorld, params: object) => number;
export type Serializer = (world: IWorld, eid: number) => any;
export type Deserializer = (world: IWorld, eid: number, data: any, updatedAt: number) => void;
export type NetworkDeserializer = (world: IWorld, eid: number, data: any, updatedAt: number) => void;
export type DiffChecker = (world: IWorld, eid: number, cache: any, updatedAt: number) => boolean;
export type SerializerFunctions = {
	deserializer: Deserializer;
	diffChecker: DiffChecker;
	networkDeserializer: NetworkDeserializer;
	serializer: Serializer;
};
export type System = (world: IWorld) => void;
export declare const NETWORK_INTERVAL: number;
export declare const F32_EPSILON = 0.00001;
export declare const TIME_EPSILON = 2;
export declare class App {
	private systems;
	private world;
	private networkAdapter;
	private streamAdapter;
	readonly userId: string;
	constructor(params: {
		canvas: HTMLCanvasElement;
		roomId: string;
		userId?: string;
	});
	private init;
	registerSystem(system: System, orderPriority?: number): void;
	deregisterSystem(system: System): void;
	getSystemOrderPriority(system: System): number;
	tick(): void;
	start(): void;
	getWorld(): IWorld;
}
export declare const Avatar: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const AvatarMouseControls: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class AvatarMouseControlsProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): AvatarMouseControlsProxy;
	allocate(): void;
	free(): void;
	get enabled(): boolean;
	set enabled(value: boolean);
}
export declare const PerspectiveCameraComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class PerspectiveCameraProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): PerspectiveCameraProxy;
	allocate(camera: PerspectiveCamera): void;
	free(): void;
	get camera(): PerspectiveCamera;
}
export declare const SceneCamera: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const FpsCamera: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Canvas: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class CanvasProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): CanvasProxy;
	allocate(canvas: HTMLCanvasElement): void;
	free(): void;
	get canvas(): HTMLCanvasElement;
}
export declare class EntityRootGroup extends Group {
	isEntityRootGroup: boolean;
	type: string;
	constructor();
}
export declare const EntityObject3D: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class EntityObject3DProxy {
	private static instance;
	private eid;
	private rootObjectMap;
	private objectsMap;
	private groupMap;
	private constructor();
	static get(eid: number): EntityObject3DProxy;
	allocate(): void;
	free(): void;
	get root(): Object3D;
	set root(obj: Object3D);
	get objects(): Object3D[];
	get group(): EntityRootGroup;
}
export declare const GltfRoot: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class GltfRootProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): GltfRootProxy;
	allocate(root: Group): void;
	free(): void;
	get root(): Group;
}
export declare const GltfAssetLoader: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class GltfAssetLoaderProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): GltfAssetLoaderProxy;
	allocate(url: string): void;
	free(): void;
	get url(): string;
}
export declare const GltfSceneLoader: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class GltfSceneLoaderProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): GltfSceneLoaderProxy;
	allocate(url: string): void;
	free(): void;
	get url(): string;
}
export declare const Grabbable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Grabbed: import("bitecs").ComponentType<{
	distance: "f32";
}>;
export declare enum KeyEventType {
	Down = 0,
	Up = 1
}
export type KeyEventValue = {
	code: number;
	type: KeyEventType;
};
export declare const KeyEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class KeyEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): KeyEventProxy;
	allocate(): void;
	add(type: KeyEventType, code: number): void;
	free(): void;
	get events(): KeyEventValue[];
}
export declare const KeyEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const KeyHold: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const KeyEventHandler: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const KeyEventHandlerReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class KeyEventHandlerProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): KeyEventHandlerProxy;
	allocate(keydownListener: (event: KeyboardEvent) => void, keyupListener: (event: KeyboardEvent) => void): void;
	free(): void;
	get keydownListener(): (event: KeyboardEvent) => void;
	get keyupListener(): (event: KeyboardEvent) => void;
	get alive(): boolean;
}
export declare const LinearMoveBackward: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearMoveForward: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearMoveLeft: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearMoveRight: import("bitecs").ComponentType<{
	speed: "f32";
}>;
export declare const LinearTranslate: import("bitecs").ComponentType<{
	duration: "f32";
	targetX: "f32";
	targetY: "f32";
	targetZ: "f32";
}>;
export declare const LinearRotate: import("bitecs").ComponentType<{
	duration: "f32";
	targetX: "f32";
	targetY: "f32";
	targetZ: "f32";
	targetW: "f32";
}>;
export declare const LinearScale: import("bitecs").ComponentType<{
	duration: "f32";
	targetX: "f32";
	targetY: "f32";
	targetZ: "f32";
}>;
export declare const MicRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MicConnectedEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MicConnectedEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MixerAnimation: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MixerAnimationProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MixerAnimationProxy;
	allocate(mixer: AnimationMixer): void;
	free(): void;
	get mixer(): AnimationMixer;
}
export declare const HasAnimations: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ActiveAnimations: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class ActiveAnimationsProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): ActiveAnimationsProxy;
	allocate(): void;
	add(action: AnimationAction): void;
	clear(): void;
	remove(action: AnimationAction): void;
	free(): void;
	get actions(): AnimationAction[];
}
export declare const ActiveAnimationsUpdated: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const LazyActiveAnimations: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type LazyActiveAnimationsValue = {
	index: number;
	paused: boolean;
	startedAt: number;
};
export declare class LazyActiveAnimationsProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): LazyActiveAnimationsProxy;
	allocate(): void;
	add(index: number, startedAt: number, paused: boolean): void;
	clear(): void;
	free(): void;
	get animations(): LazyActiveAnimationsValue[];
}
export declare enum MouseButtonEventType {
	Down = 0,
	Up = 1
}
export declare enum MouseButtonType {
	Left = 0,
	Middle = 1,
	Right = 2
}
export type MouseButtonEventValue = {
	button: MouseButtonType;
	x: number;
	y: number;
	type: MouseButtonEventType;
};
export declare const MouseButtonEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseButtonEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseButtonHold: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MouseButtonEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MouseButtonEventProxy;
	allocate(): void;
	add(type: MouseButtonEventType, button: MouseButtonType, x: number, y: number): void;
	free(): void;
	get events(): MouseButtonEventValue[];
}
export declare const MouseMoveEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseMoveEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type MouseMoveEventValue = {
	x: number;
	y: number;
};
export declare class MouseMoveEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MouseMoveEventProxy;
	allocate(): void;
	add(x: number, y: number): void;
	free(): void;
	get events(): MouseMoveEventValue[];
}
export type MousePositionValue = {
	x: number;
	y: number;
};
export declare const MousePosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const PreviousMousePosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MousePositionProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): MousePositionProxy;
	allocate(): void;
	free(): void;
	update(x: number, y: number): void;
	get x(): number;
	get y(): number;
}
export declare class PreviousMousePositionProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): PreviousMousePositionProxy;
	allocate(): void;
	free(): void;
	update(x: number, y: number): void;
	get x(): number;
	get y(): number;
}
export declare const MouseButtonEventHandler: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseButtonEventHandlerReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MouseButtonEventHandlerProxy {
	private static instance;
	private eid;
	private targets;
	private listeners;
	private constructor();
	static get(eid: number): MouseButtonEventHandlerProxy;
	init(target: HTMLElement): void;
	allocate(mousedownListener: (event: MouseEvent) => void, mouseupListener: (event: MouseEvent) => void, contextmenuListener: (event: MouseEvent) => void): void;
	free(): void;
	get target(): HTMLElement;
	get mousedownListener(): (event: MouseEvent) => void;
	get mouseupListener(): (event: MouseEvent) => void;
	get contextmenuListener(): (event: MouseEvent) => void;
	get alive(): boolean;
	get listenersAlive(): boolean;
}
export declare const MouseMoveEventHandler: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const MouseMoveEventHandlerReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class MouseMoveEventHandlerProxy {
	private static instance;
	private eid;
	private targets;
	private listeners;
	private constructor();
	static get(eid: number): MouseMoveEventHandlerProxy;
	init(target: HTMLElement): void;
	allocate(listener: (event: MouseEvent) => void): void;
	free(): void;
	get listener(): (event: MouseEvent) => void;
	get target(): HTMLElement;
	get alive(): boolean;
	get listenersAlive(): boolean;
}
// Generated by dts-bundle-generator v8.0.1
export type Callback = (payload?: any) => void;
declare class StateAdapter {
	private channel;
	private eventListenerMap;
	readonly userId: string;
	constructor(params: {
		roomId: string;
		url?: string;
		userId: string;
	});
	addEventListener(name: string, callback: Callback): void;
	removeEventListener(name: string): void;
	push(name: string, data: any): void;
}
export declare enum NetworkMessageType {
	AddComponent = "add_component",
	CreateEntity = "create_entity",
	RemoveEntity = "remove_entity",
	RemoveComponent = "remove_component",
	TextMessage = "text_message",
	UpdateComponent = "update_component",
	UserJoined = "user_joined",
	UserLeft = "user_left",
	UserList = "user_list"
}
export declare enum NetworkedType {
	Local = "local",
	Remote = "remote",
	Shared = "shared"
}
export type CacheData = any;
export type NetworkedComponent = {
	cache: CacheData;
	owner: string;
	updatedAt: number;
	version: number;
};
export declare const Local: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Remote: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Shared: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Networked: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class NetworkedProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): NetworkedProxy;
	allocate(networkId: string, type: NetworkedType, creator: string, prefabName: string, prefabParams: any): void;
	free(): void;
	hasNetworkedComponent(key: string): boolean;
	initNetworkedComponent(key: string, cache: CacheData, owner: string, updatedAt: number, version: number): void;
	updateNetworkedComponent(key: string, cache: CacheData, owner: string, updatedAt: number, version: number): void;
	getNetworkedComponent(key: string): NetworkedComponent;
	removeNetworkedComponent(key: string): void;
	get creator(): string;
	get networkId(): string;
	get prefabName(): string;
	get prefabParams(): any;
	get type(): NetworkedType;
}
export declare const NetworkedEntityManager: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class NetworkedEntityManagerProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): NetworkedEntityManagerProxy;
	allocate(): void;
	free(): void;
	add(eid: number, networkId: string, userId: string): void;
	remove(networkId: string): void;
	getNetworkId(eid: number): string;
	getNetworkIdsByUserId(userId: string): string[];
	clearNetworkIdsByUserId(userId: string): void;
	getEid(networkId: string): number;
	deleted(networkId: string): boolean;
}
export declare const StateClient: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class StateClientProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StateClientProxy;
	allocate(adapter: StateAdapter): void;
	free(): void;
	get adapter(): StateAdapter;
}
export declare const NetworkEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type NetworkEventValue = {
	data: any;
	type: NetworkMessageType;
};
export declare class NetworkEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): NetworkEventProxy;
	allocate(): void;
	add(type: NetworkMessageType, data: any): void;
	free(): void;
	get events(): NetworkEventValue[];
}
export declare const NetworkEventReceiver: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkEventReceiverReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const TextMessageNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const UserNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const EntityNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ComponentNetworkEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkEventSender: import("bitecs").ComponentType<{
	lastSendTime: "f32";
}>;
export declare const NetworkedPosition: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkedQuaternion: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkedScale: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NetworkedMixerAnimation: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Prefabs: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class PrefabsProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): PrefabsProxy;
	allocate(): void;
	free(): void;
	register(key: string, prefab: Prefab): void;
	deregister(key: string): void;
	get(key: string): Prefab;
}
export declare const Raycastable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Raycasted: import("bitecs").ComponentType<{
	distance: "f32";
}>;
export declare const RaycasterComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class RaycasterProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): RaycasterProxy;
	allocate(raycaster: Raycaster): void;
	free(): void;
	get raycaster(): Raycaster;
}
export declare const Renderer: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class RendererProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): RendererProxy;
	allocate(renderer: WebGLRenderer): void;
	free(): void;
	get renderer(): WebGLRenderer;
}
export declare const RoomId: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class RoomIdProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): RoomIdProxy;
	allocate(roomId: string): void;
	free(): void;
	get roomId(): string;
}
export declare const SceneComponent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const InScene: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class SceneProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SceneProxy;
	allocate(scene: Scene): void;
	free(): void;
	get scene(): Scene;
}
export declare const SceneObject: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const SceneEnvironmentMapLoader: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class SceneEnvironmentMapLoaderProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SceneEnvironmentMapLoaderProxy;
	allocate(url: string): void;
	free(): void;
	get url(): string;
}
export declare const Selectable: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Selected: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare enum SelectedType {
	Deselected = 0,
	Selected = 1
}
export declare const SelectedEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type SelectedEventValue = {
	eid: number;
	type: SelectedType;
};
export declare class SelectedEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SelectedEventProxy;
	allocate(): void;
	add(type: SelectedType, eid: number): void;
	free(): void;
	get events(): SelectedEventValue[];
}
export declare const SelectedEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Serializers: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class SerializersProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): SerializersProxy;
	allocate(): void;
	free(): void;
	register(component: IComponent, serializers: SerializerFunctions): void;
	deregister(component: IComponent): void;
	get(component: IComponent): SerializerFunctions;
	has(component: IComponent): boolean;
}
export declare const ComponentKeys: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class ComponentKeysProxy {
	private static instance;
	private eid;
	private toComponents;
	private toKeys;
	private constructor();
	static get(eid: number): ComponentKeysProxy;
	allocate(): void;
	free(): void;
	register(key: string, component: IComponent): void;
	deregister(key: string): void;
	getComponent(key: string): IComponent;
	hasComponent(key: string): boolean;
	getKey(component: IComponent): string;
	hasKey(component: IComponent): boolean;
}
declare class StreamAdapter {
	private device;
	private socket;
	private connected;
	private joined;
	private recvTransport;
	private sendTransport;
	private connectedEventListener;
	private joinedEventListener;
	private disconnectedEventListener;
	private newPeerEventListener;
	private joinedPeerEventListener;
	private leftPeerEventListener;
	private exitedPeerEventListener;
	private newConsumerEventListener;
	private consumerInfoQueue;
	constructor(serverUrl?: string);
	connect(roomId: string, peerId: string): Promise<{
		id: string;
		joined: boolean;
	}[]>;
	on(eventName: string, callback: (...args: any[]) => void): void;
	off(eventName: string): void;
	private handleConsumerInfos;
	exit(): Promise<void>;
	join(): Promise<void>;
	leave(): Promise<void>;
	private createSendTransport;
	private createRecvTransport;
	produce(track: MediaStreamTrack): Promise<void>;
}
export declare enum StreamMessageType {
	Connected = "connected",
	Joined = "joined",
	Disconnected = "disconnected",
	ExitedPeer = "exitedPeer",
	JoinedPeer = "joinedPeer",
	LeftPeer = "leftPeer",
	NewConsumer = "newConsumer",
	NewPeer = "newPeer"
}
export declare const StreamClient: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class StreamClientProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StreamClientProxy;
	allocate(adapter: StreamAdapter): void;
	free(): void;
	get adapter(): StreamAdapter;
}
export declare const StreamConnectRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamJoinRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamLeaveRequestor: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type StreamEventValue = {
	data: any;
	type: StreamMessageType;
};
export declare class StreamEventProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StreamEventProxy;
	allocate(): void;
	add(type: StreamMessageType, data: any): void;
	free(): void;
	get events(): StreamEventValue[];
}
export declare const StreamEventReceiver: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamEventReceiverReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ConnectedStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const DisconnectedStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const JoinedStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const ExitedPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const JoinedPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const LeftPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NewConsumerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const NewPeerStreamEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const StreamRemotePeers: import("bitecs").ComponentType<import("bitecs").ISchema>;
export type StreamRemotePeersValue = Map<string, {
	audio?: HTMLAudioElement;
	id: string;
	joined: boolean;
}>;
export declare class StreamRemotePeersProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): StreamRemotePeersProxy;
	allocate(): void;
	free(): void;
	remove(id: string): void;
	get peers(): StreamRemotePeersValue;
}
export declare const StreamRemotePeerRegister: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const Time: import("bitecs").ComponentType<{
	delta: "f32";
	elapsed: "f32";
}>;
export declare class TimeProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): TimeProxy;
	allocate(clock: Clock, delta: number, elapsed: number): void;
	free(): void;
	get clock(): Clock;
	get delta(): number;
	set delta(delta: number);
	get elapsed(): number;
	set elapsed(elapsed: number);
}
export declare const TransformUpdated: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const UserId: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class UserIdProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): UserIdProxy;
	allocate(userId: string): void;
	free(): void;
	get userId(): string;
}
export declare const WindowResizeEvent: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WindowResizeEventListener: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WindowSize: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WindowResizeEventHandler: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare const WindowResizeEventHandlerReady: import("bitecs").ComponentType<import("bitecs").ISchema>;
export declare class WindowResizeEventHandlerProxy {
	private static instance;
	private eid;
	private map;
	private constructor();
	static get(eid: number): WindowResizeEventHandlerProxy;
	allocate(listener: () => void): void;
	free(): void;
	get listener(): () => void;
	get alive(): boolean;
}
export type SerializedMixerAnimation = {
	index: number;
	paused: boolean;
	time: number;
}[];
export declare const mixerAnimationSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedMixerAnimation, updatedAt: number) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedMixerAnimation, updatedAt: number) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedMixerAnimation, updatedAt: number) => void;
	serializer: (world: IWorld, eid: number) => SerializedMixerAnimation;
};
export type SerializedPosition = [
	x: number,
	y: number,
	z: number
];
export type SerializedQuaternion = [
	x: number,
	y: number,
	z: number,
	w: number
];
export type SerializedScale = [
	x: number,
	y: number,
	z: number
];
export declare const positionSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedPosition) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedPosition) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedPosition) => void;
	serializer: (world: IWorld, eid: number) => SerializedPosition;
};
export declare const quaternionSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedQuaternion) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedQuaternion) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedQuaternion) => void;
	serializer: (world: IWorld, eid: number) => SerializedQuaternion;
};
export declare const scaleSerializers: {
	deserializer: (world: IWorld, eid: number, data: SerializedScale) => void;
	diffChecker: (world: IWorld, eid: number, cache: SerializedScale) => boolean;
	networkDeserializer: (world: IWorld, eid: number, data: SerializedScale) => void;
	serializer: (world: IWorld, eid: number) => SerializedScale;
};
export declare const avatarKeyControlsSystem: (world: IWorld) => void;
export declare const avatarMouseControlsSystem: (world: IWorld) => void;
export declare const canvasSystem: (world: IWorld) => void;
export declare const entityObject3DSystem: (world: IWorld) => void;
export declare const fpsCameraSystem: (world: IWorld) => void;
export declare const gltfSystem: (world: IWorld) => void;
export declare const gltfAssetLoadSystem: (world: IWorld) => void;
export declare const gltfSceneLoadSystem: (world: IWorld) => void;
export declare const grabSystem: (world: IWorld) => void;
export declare const grabbedObjectsMouseTrackSystem: (world: IWorld) => void;
export declare const keyEventHandleSystem: (world: IWorld) => void;
export declare const keyEventClearSystem: (world: IWorld) => void;
export declare const lazilyActivateAnimationSystem: (world: IWorld) => void;
export declare const linearMoveSystem: (world: IWorld) => void;
export declare const linearTransformSystem: (world: IWorld) => void;
export declare const micRequestSystem: (world: IWorld) => void;
export declare const micEventClearSystem: (world: IWorld) => void;
export declare const mixerAnimationSystem: (world: IWorld) => void;
export declare const clearActiveAnimationsUpdatedSystem: (world: IWorld) => void;
export declare const mouseButtonEventHandleSystem: (world: IWorld) => void;
export declare const mouseButtonEventClearSystem: (world: IWorld) => void;
export declare const mouseMoveEventHandleSystem: (world: IWorld) => void;
export declare const mouseMoveEventClearSystem: (world: IWorld) => void;
export declare const mousePositionTrackSystem: (world: IWorld) => void;
export declare const mouseRaycastSystem: (world: IWorld) => void;
export declare const mouseSelectSystem: (world: IWorld) => void;
export declare const networkedSystem: (world: IWorld) => void;
export declare const networkedEntitySystem: (world: IWorld) => void;
export declare const networkEventHandleSystem: (world: IWorld) => void;
export declare const networkEventClearSystem: (world: IWorld) => void;
export declare const networkSendSystem: (world: IWorld) => void;
export declare const perspectiveCameraSystem: (world: IWorld) => void;
export declare const prefabsSystem: (world: IWorld) => void;
export declare const clearRaycastedSystem: (world: IWorld) => void;
export declare const raycasterSystem: (world: IWorld) => void;
export declare const renderSystem: (world: IWorld) => void;
export declare const rendererSystem: (world: IWorld) => void;
export declare const sceneSystem: (world: IWorld) => void;
export declare const sceneEnvironmentMapLoadSystem: (world: IWorld) => void;
export declare const selectedEventClearSystem: (world: IWorld) => void;
export declare const streamConnectionSystem: (world: IWorld) => void;
export declare const streamEventHandleSystem: (world: IWorld) => void;
export declare const streamEventClearSystem: (world: IWorld) => void;
export declare const streamRemotePeerRegisterSystem: (world: IWorld) => void;
export declare const timeSystem: (world: IWorld) => void;
export declare const clearTransformUpdatedSystem: (world: IWorld) => void;
export declare const updateMatricesSystem: (world: IWorld) => void;
export declare const windowResizeEventHandleSystem: (world: IWorld) => void;
export declare const windowResizeEventClearSystem: (world: IWorld) => void;
export declare const removeEntityIfNoComponent: (world: IWorld, eid: number) => boolean;
export declare const hasComponents: (world: IWorld, components: Component[], eid: number) => boolean;
export declare function loadGltfBitecs(world: IWorld, eid: number, url: string): Generator<void, GLTF>;
export declare function toGenerator<T>(pending: Promise<T>): Generator<void, T>;
export declare const addObject3D: (world: IWorld, obj: Object3D, eid: number) => void;
export declare const removeObject3D: (world: IWorld, obj: Object3D, eid: number) => void;
export declare const hasObject3D: (world: IWorld, obj: Object3D, eid: number) => boolean;
export declare const addAnimation: (world: IWorld, eid: number, action: AnimationAction) => void;
export declare const createNetworkedEntity: (world: IWorld, type: NetworkedType.Local | NetworkedType.Shared, prefabName: string, prefabParams?: any) => number;
export declare const registerPrefab: (world: IWorld, key: string, prefab: Prefab) => void;
export declare const deregisterPrefab: (world: IWorld, key: string) => void;
export declare const getPrefab: (world: IWorld, key: string) => Prefab;
export declare const registerSerializers: (world: IWorld, key: string, component: IComponent, serializers: SerializerFunctions) => void;
export declare const deregisterSerializers: (world: IWorld, key: string) => void;
export declare const getSerializers: (world: IWorld, key: string) => SerializerFunctions;
export declare const hasSerializers: (world: IWorld, key: string) => boolean;
export declare const getComponentKey: (world: IWorld, component: IComponent) => string;
export declare const hasComponentKey: (world: IWorld, component: IComponent) => boolean;
export declare function loadGltf(url: string): Generator<void, GLTF>;
export declare const resizeObject3D: (obj: Object3D, targetSize?: number) => Object3D;
export declare const recenterObject3D: (obj: Object3D) => Object3D;
export declare function loadHdrTexture(url: string): Generator<void, Texture>;
export declare const collectClips: (root: Object3D) => AnimationClip[];
export declare const getTimeProxy: (world: IWorld) => TimeProxy;

export {};
